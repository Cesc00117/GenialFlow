requirement <- as.data.frame(cbind(id_card,income_prf,house_prf,assets_prf,insurance_prf,credit_prf,age_require))
#资产证明
assets_prf<-c()
for(i in 1:n){
if(sapply('资产证明',regexpr,loan[i,15])>0){
assets_prf<-c(assets_prf,1)
}
if(sapply('资产证明',regexpr,loan[i,15])<=0){
assets_prf<-c(assets_prf,0)
}
}
requirement <- as.data.frame(cbind(id_card,income_prf,house_prf,assets_prf,insurance_prf,credit_prf,age_require))
for(i in 1:ncol(requirement)) {requirement[, i] <- as.factor(requirement[, i])}
library(stringr)
colnames(df)[7] <- 'monthly_fee'
percent <- str_extract_all(df$monthly_fee,"[0.00-9.00]+%")
percent_vec <- vector(mode="character", length=nrow(df))
monthly_fee <- vector(mode="character", length=nrow(df))
for(i in 1:length(percent)) percent_vec[i] <- percent[[i]]
percent_vec <- lapply(percent_vec, function(x) as.numeric(sub("%", "", x))/100)
for(i in 1:length(percent_vec)) monthly_fee[i] <- percent_vec[[i]]
df$monthly_fee <- as.numeric(monthly_fee)
# df1
df1 <- df[, -c(1,2, 3,4,5,15)]
colnames(df1) <- c('cost', 'monthly_fee', 'term_min', 'term_max', 'repay_way', 'lend_time', 'check_time', 'guarantee_way', 'num',
'type', 'city_lv', 'range')
colnames(df1) <- c('cost', 'monthly_fee', 'term_min', 'term_max', 'repay_way', 'lend_time', 'check_time', 'guarantee_way', 'num',
'type', 'city_lv')
df1 <-as.data.frame(cbind(df1, requirement))
df1$repay_way <- factor(df1$repay_way)
df1$guarantee_way <- factor(df1$guarantee_way)
df1$num <- factor(df1$num)
df1$lend_time <- as.numeric(df1$lend_time)
df1 <- na.omit(df1)
summary(df1)
fit <- glm(num~., family = binomial, data = df1)
summary(fit)
aic.fit=step(fit,k=2)
aic.fit=step(fit,k=2)
summary(aic.fit)
plot(roc(df1$num, predict(aic.fit, df1, type='response')),
print.auc = T, print.thres = T, xlab='特异度', ylab='灵敏度')
treelm <- rpart(num~., data = df1)
fancyRpartPlot(treelm, sub='')
plot(roc(df1$num, predict(treelm, df1, type='prob')[,2]),
print.auc = T, print.thres = T, xlab='特异度', ylab='灵敏度')
summary(aic.fit)
plot(roc(df1$num, predict(aic.fit, df1, type='response')),
print.auc = T, print.thres = T, xlab='特异度', ylab='灵敏度')
summary(aic.fit)
requirement <- as.data.frame(cbind(id_card,income_prf,house_prf,assets_prf,insurance_prf,credit_prf))
for(i in 1:ncol(requirement)) {requirement[, i] <- as.factor(requirement[, i])}
# df1
df1 <- df[, -c(1,2, 3,4,5,15)]
colnames(df1) <- c('cost', 'monthly_fee', 'term_min', 'term_max', 'repay_way', 'lend_time', 'check_time', 'guarantee_way', 'num',
'type', 'city_lv')
df1 <-as.data.frame(cbind(df1, requirement))
df1$repay_way <- factor(df1$repay_way)
df1$guarantee_way <- factor(df1$guarantee_way)
df1$num <- factor(df1$num)
df1$lend_time <- as.numeric(df1$lend_time)
df1 <- na.omit(df1)
summary(df1)
fit <- glm(num~., family = binomial, data = df1)
summary(fit)
aic.fit=step(fit,k=2)
summary(aic.fit)
plot(roc(df1$num, predict(aic.fit, df1, type='response')),
print.auc = T, print.thres = T, xlab='特异度', ylab='灵敏度')
treelm <- rpart(num~., data = df1)
fancyRpartPlot(treelm, sub='')
plot(roc(df1$num, predict(treelm, df1, type='prob')[,2]),
print.auc = T, print.thres = T, xlab='特异度', ylab='灵敏度')
requirement <- as.data.frame(cbind(id_card,income_prf,house_prf,assets_prf,insurance_prf,credit_prf))
View(requirement)
requirement <- as.data.frame(cbind(id_card,income_prf,house_prf,assets_prf,insurance_prf,credit_prf))
View(requirement)
dt3 = data.frame(obj = c('身份证','收入证明','房产证','资产证明','保险单', '信用记录'), val = c(sum(id_card),
sum(income_prf),
sum(house_prf),
sum(assets_prf),
sum(insurance_prf),
sum(credit_prf)))
View(dt3)
ggplot(dt3, aes(x = obj, y = val, fill = obj, group = factor(1))) +
geom_bar(stat = "identity") +
theme_economist()
dt3 = data.frame(申请条件 = c('身份证','收入证明','房产证','资产证明','保险单', '信用记录'), 频数 = c(sum(id_card),
sum(income_prf),
sum(house_prf),
sum(assets_prf),
sum(insurance_prf),
sum(credit_prf)))
ggplot(dt3, aes(x = 申请条件, 频数 = val, fill = obj, group = factor(1))) +
geom_bar(stat = "identity") +
theme_economist()
ggplot(dt3, aes(x = 申请条件, y = 频数, fill = obj, group = factor(1))) +
geom_bar(stat = "identity") +
theme_economist()
ggplot(dt3, aes(x = 申请条件, y = 频数, fill = 申请条件, group = factor(1))) +
geom_bar(stat = "identity") +
theme_economist()
ggplot(data = dt2, aes(Var2, Freq, group = Var1)) +
geom_col(aes(fill = Var1), position = "dodge")  +
theme_economist()
View(dt2)
colnames(dt2) <- c('有/无人申请', '城市类型', '频数')
ggplot(data = dt2, aes(城市类型, 频数, group = 有/无人申请)) +
geom_col(aes(fill = 有/无人申请), position = "dodge")  +
theme_economist()
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
ggplot(data = dt2, aes(城市类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
View(dt1)
colnames(dt1) <- c('是否有人申请', '机构类型', '频数')
ggplot(data = dt2, aes(机构类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
ggplot(data = dt1, aes(机构类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
dt2$是否有人申请[which(dt2$是否有人申请 == 1)] <- 有
dt2$是否有人申请[which(dt2$是否有人申请 == 1)] <- '有'
dt2$是否有人申请[which(dt2$是否有人申请 == 0)] <- '无'
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
ggplot(data = dt2, aes(城市类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
# 簇状柱状图
dt2 <- as.data.frame(table(df$num, df$city_lv))
dt2$是否有人申请[which(dt2$是否有人申请 == 1)] <- '有'
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
dt2$是否有人申请[which(dt2$是否有人申请 == 1)] <- '有'
dt2$是否有人申请[which(dt2$是否有人申请 == 0)] <- '无'
# 簇状柱状图
dt2 <- as.data.frame(table(df$num, df$city_lv))
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
dt2$是否有人申请[which(dt2$是否有人申请 == 1)]
which(dt2$是否有人申请 == 1)
# 簇状柱状图
dt2 <- as.data.frame(table(df$num, df$city_lv))
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
dt2[which(dt2$是否有人申请 == 1)， 1] <- '有'
dt2[which(dt2$是否有人申请 == 1), 1] <- '有'
# 簇状柱状图
dt2 <- as.data.frame(table(df$num, df$city_lv))
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
dt2[which(dt2$是否有人申请 == 1), 1] <- '有'
# 簇状柱状图
dt1 <- as.data.frame(table(df$num, df$type))
colnames(dt1) <- c('是否有人申请', '机构类型', '频数')
ggplot(data = dt1, aes(机构类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
ggplot(data = dt2, aes(城市类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
# 簇状柱状图
dt2 <- as.data.frame(table(df$num, df$city_lv))
colnames(dt2) <- c('是否有人申请', '城市类型', '频数')
ggplot(data = dt2, aes(城市类型, 频数, group = 是否有人申请)) +
geom_col(aes(fill = 是否有人申请), position = "dodge")  +
theme_economist()
View(dt)
View(dt2)
View(dt1)
17/(17+52)
42/(42+130)
336/(336+469)
248+352-147-299
View(dt2)
147/(147+299)
248/(248+352)
View(df)
View(df1)
View(df)
View(df1)
# 读入停词表
mystopwords=unlist(read.table("mystopwords.txt", encoding = 'UTF-8',
stringsAsFactors = F))
library(WindR)
install.packages('WindR')
install.packages("E:/Wind数据接口/bin/WindR.tar.gz", repos = NULL, type="source")R
install.packages("E:/Wind数据接口/bin/WindR.tar.gz", repos = NULL, type="source")
library(WindR)
w.start()
w.menu()
w.isconnected()
data <- w.wsq('600000.SH','rt_low','rt_last_vol', func=w.demoCallback())
data <- w.wsq('600000.SH','rt_low','rt_last_vol', func=w.demoCallback)
data <- w.wsq('600000.SH','rt_low','rt_last_vol')
View(data)
data
data <- w.wsq('600000.SH','rt_low','rt_last')
data
data <- w.wsq('600000.SH','rt_low')
data
data <- w.wsq('600000.SH','rt_low')
data
data <- w.wsq('600000.SH','last_trade_day')
data
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Da
te()-1)
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Da
te(-1))
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Date(-1))
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Date()-1)
data
View(data)
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Date()-1) # 获取历史序列数据
df <- data$Data # 获取数据框
View(data)
View(df)
w.menu()              # 菜单显示开关
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Date()-1) # 获取历史序列数据
w.asDateTime(data$Data[,2])
df <- data$Data # 获取数据框
View(df)
data<-w.wss("600000.SH,000002.SZ","last_trade_day,pre_close")
w.asDateTime(data$Data[,2],asdate=T)#转换成日期形式
data<-w.wss("600000.SH,000002.SZ","last_trade_day,pre_close")
w.asDateTime(data$Data[,2],asdate=T)#转换成日期形式
df <- data$Data # 获取数据框
View(df)
data$Data[,2] <- w.asDateTime(data$Data[,2],asdate=T)#转换成日期形式
df <- data$Data # 获取数据框
# 转换时间格式
data <- w.wss("600000.SH,000002.SZ","last_trade_day,pre_close")
data$Data[,2] <- w.asDateTime(data$Data[,2],asdate=T)#转换成日期形式
# 转换时间格式
data <- w.wss("600000.SH,000002.SZ","last_trade_day,pre_close")
data$Data[,2] <- w.asDateTime(data$Data[,2],asdate=T)#转换成日期形式
df1 <- data$Data # 获取数据框
# 获取历史序列
data<-w.wsd("600000.SH","close,amt","2016-04-30",Sys.Date()-1)
df2 <- data$Data
View(df1)
View(df2)
# 获取截面数据
data<-w.wss("600000.SH,000001.SZ","eps_ttm,orps,surpluscapitalps","rptDate=20151231")
View(data)
df3 <- data$Data
View(df3)
# 获取截面数据
data <- w.wss('600030.SH,600031.SH','LAST,HIGH,LOW,OPEN')
df3 <- data$Data
View(df3)
# 获取截面数据
data <- w.wss('600030.SH','LAST')
df3 <- data$Data
View(df3)
# 获取截面数据
data <- w.wss('600000.SH','last,high')
df3 <- data$Data
View(df3)
# 获取截面数据
data <- w.wss('600000.SH','last,high')
data
house <- read.csv('房地产净利润.csv', header = T,
stringsAsFactors = F)
setwd('D:\\R/GenialFlow')
house <- read.csv('房地产净利润.csv', header = T,
stringsAsFactors = F)
steel <- read.csv('钢铁净利润.csv', header = T,
stringsAsFactors = F)
View(house)
View(steel)
house <- read.csv('房地产净利润.csv', header = T,
stringsAsFactors = F)
steel <- read.csv('钢铁净利润.csv', header = T,
stringsAsFactors = F)
########################################
# idxMedian函数
# 功能：获取行业指标（中位数）
# 输入：行业数据框（行：所有企业 列：开始时间-结束时间 元素：指标的值）
# 输出：行名称为时间点，一列元素为指标中位数的dataframe
########################################
idxMedian <- function(df, time_start, time_end){
num <- df[,4:ncol(df)]
m <- as.matrix(num)
m[which(m==0)] <- NA
num <- as.data.frame(m)
for(i in 1:ncol(num)) num[,i] <- as.numeric(num[,i])
# 提取指标
idx <- c()
for(i in 1:ncol(num)){
mid <- median(num[,i], na.rm = T)
idx <- c(idx, mid)
}
idx <- as.numeric(idx)
rlt <- as.data.frame(idx,
row.names =
as.character(
seq.Date(
from = as.Date(time_start),
to = as.Date(time_end),
by = 'quarter')))
return(rlt)
}
# 试用
idx_house <- idxMedian(df = house,
time_start = "1993/3/1",
time_end = "2017/12/1")
idx_steel <- idxMedian(df = steel,
time_start = "1993/3/1",
time_end = "2017/12/1")
View(idx_steel)
View(idx_house)
is.na(idx_house[,1])
which(idx_house[,1] == NA)
which(is.na(idx_house))
idx_house[,1][35]
idx_house[,1][36]
ts <- idx_house[,1][36:nrow(idx_house)]
library('lmtest')
install.packages('lmtest')
library('lmtest')
library('lmtest')
setwd('D:\\R/GenialFlow')
#setwd('E:\\workspace_qdf/R')
library('zoo')  # 程序包：时间序列
library('nnet') # 程序包：编码
# 读取数据+调整
eco <- read.csv('ECO.csv', header = T)
eco <- eco[-1,]
row.names(eco) <- 1:nrow(eco)
eco <- eco[82:(nrow(eco)-4),]
eco[,1] <- paste(eco[,1],'-01',sep='')
eco[,1] <- as.Date(eco[,1])
# 获取时序+指标数值化
tseries <- eco[,1]
idx <- eco[,c(2,3,4,8)]
idx <- as.data.frame(apply(idx, 2, as.numeric))
# 对月度数据取平均得到季度数据
draw <- seq(from=3, to=nrow(idx),by=3)
quaterData <- idx[draw,4]
tseries <- tseries[draw]
monthData <- as.data.frame(cbind(round((idx[draw-2,1]+idx[draw-1,1]+idx[draw,1])/3,4),
round((idx[draw-2,2]+idx[draw-1,2]+idx[draw,2])/3,4),
round((idx[draw-2,3]+idx[draw-1,3]+idx[draw,3])/3,4)))
# 获得数据的初步形式
dat <- as.data.frame(cbind(quaterData,monthData),
stringsAsFactors = F)
row.names(dat) <- tseries
colnames(dat) <- c('GDP平减指数','PPI', '工业增加值','CPI')
# 标准化
scale_dat <- as.data.frame(apply(dat, 2, scale))
########################################
# Cycle函数
# 功能：获取经济周期
# 输入：经济增长指标，通货膨胀指标
# 输出：经济周期（含哑变量）的dataframe
########################################
Cycle <- function(var_eco, var_inf, k, lagT,
ifplot = FALSE){
# 移动平均+描述观察
k = k # 窗宽
zoo1 <- zoo(var_inf, tseries) # 通货膨胀指标
zoo2 <- zoo(var_eco, tseries) # 经济增长指标
if(k==0) dat1 <- cbind(as.data.frame(zoo1),as.vector(zoo2))
else{
rm1 <- rollmean(zoo1,k)
rm2 <- rollmean(zoo2,k)
if(ifplot){  # 是否画图
par(mfrow=c(2,1))
plot(rm1, xlab = '时间', ylab = '通货膨胀')
plot(rm2, xlab = '时间', ylab = '经济增长')
}
dat1 <- cbind(as.data.frame(rm1),as.vector(rm2))
}
colnames(dat1) <- c('通货膨胀','经济增长')
# 经济周期
lagT = lagT # 差分期数
tseries_rm <- row.names(dat1)
tseries_diff <- tseries_rm[(lagT+1):length(tseries_rm)]
eco_up <- tseries_diff[which(diff(dat1[,2], lag = lagT)>=0)] # 经济增长（减缓）期
eco_down <- tseries_diff[which(diff(dat1[,2], lag = lagT)<0)]
inflation <- tseries_diff[which(diff(dat1[,1], lag = lagT)>=0)] # 通货膨胀（通缩）期
deflation <- tseries_diff[which(diff(dat1[,1], lag = lagT)<0)]
overheated <- intersect(eco_up,inflation)    # 过热（美林投资时钟）
stagflation <- intersect(eco_down,inflation) # 滞涨
decline <- intersect(eco_down,deflation)     # 衰退
recovery <- intersect(eco_up,deflation)      # 复苏
state <- c()
# 1过热 2滞涨 3衰退 4复苏
for(i in 1:length(tseries_diff)){
if(tseries_diff[i] %in% overheated) state <- c(state,"过热")
else if(tseries_diff[i] %in% stagflation) state <- c(state,"滞涨")
else if(tseries_diff[i] %in% decline) state <- c(state,"衰退")
else if(tseries_diff[i] %in% recovery) state <- c(state,"复苏")
else state <- c(state, NA)
}
dat2 <- cbind(dat1[(lagT+1):nrow(dat1),],state)
# 分类变量编码
state_dummy <- as.data.frame(class.ind(dat2[,3]))
dat3 <- cbind(dat2[,c(1,2,3)], state_dummy)
return(dat3)
}
# 试用
# 工业增加值->经济增长，GDP平减->通货膨胀
# 具体指标查看scale_dat的列名称
gT1k0 <- Cycle(var_eco = scale_dat[,3], # 工业增加值
var_inf = scale_dat[,1], # GDP平减
lagT = 1,
k = 0)
View(gT1k0)
View(gT1k0)
cycleRobust <- function(dfCycle, y, dif = FALSE){
fit <- cbind(dfCycle, y[row.names(dfCycle),])
colnames(fit)[8] <- 'idx'
fit[,8] <- scale(fit[,8])
if(dif){
m1 <- lm(idx[2:nrow(fit)]~state[1:(nrow(fit)-1)], data = fit)
}
m1 <- lm(idx~state, data = fit)
summary(m1) # 函数没有返回，作用是查看回归结果
}
cycleRobust <- function(dfCycle, y, dif = FALSE){
fit <- cbind(dfCycle, y[row.names(dfCycle),])
colnames(fit)[8] <- 'idx'
fit[,8] <- scale(fit[,8])
if(dif){
m1 <- lm(idx[2:nrow(fit)]~state[1:(nrow(fit)-1)], data = fit)
}
m1 <- lm(idx~state, data = fit)
return(m1)
}
dwtest(ts)
cycleRobust(gT1k0, idx_steel)
res <- cycleRobust(gT1k0, idx_steel)
summary(res)
dwtest(res)
plot(res$residuals)
dwtest(res)
View(idx_steel)
res <- cycleRobust(gT1k0, idx_house)
dwtest(res)
plot(res$residuals)
library('ts') # 程序包：时间序列检验
install.packages('ts')
library('urca') # 程序包：时间序列检验
install.packages('urca')
library('urca') # 程序包：时间序列检验
library('FinTS') # 程序包：时间序列检验
install.packages('FinTS')
dat <- cycleRobust(gT1k0, idx_house)
View(dat)
cycleRobust <- function(dfCycle, y, dif = FALSE){
fit <- cbind(dfCycle, y[row.names(dfCycle),])
colnames(fit)[8] <- 'idx'
fit[,8] <- scale(fit[,8])
if(dif){
m1 <- lm(idx[2:nrow(fit)]~state[1:(nrow(fit)-1)], data = fit)
}
m1 <- lm(idx~state, data = fit)
return(as.data.frame(fit))
}
dat <- cycleRobust(gT1k0, idx_house)
View(dat)
dat <- dat[,c(3, 8)]
View(dat)
plot.ts(dat$idx)
View(dat)
plot.ts(dat$idx ~ rownames(dat))
View(dat)
plot(dat$idx ~ rownames(dat))
plot(dat$idx)
library(tseries)#载入tseries包
install.packages('tseries')
library(tseries)#载入tseries包
library(tseries)#载入tseries包
library('tseries')#载入tseries包
ts <- dat[,2]
adf.test(ts)
adf.test(na.omit(ts))
grangertest(dat$state, dat$idx)
grangertest(dat$state~dat$idx)
grangertest(dat$state~dat$idx)
grangertest(dat$idx~dat$state)
grangertest(dat$state~dat$idx)
grangertest(dat$idx~dat$state)
grangertest(dat$idx~dat$state)
grangertest(dat$idx~dat$state)
grangertest(dat$state~dat$idx)
grangertest(dat$idx~dat$state)
grangertest(dat$idx, dat$state)
View(eco)
grangertest(eco[,2], eco[,3])
grangertest(dat$state, dat$idx)
grangertest(dat$idx, dat$state)
grangertest(dat$state, dat$idx)
dat <- cycleRobust(gT1k0, idx_steel)
dat <- dat[,c(3, 8)]
ts <- dat[,2]
adf.test(na.omit(ts)) # 平稳性检验
grangertest(dat$idx, dat$state)
grangertest(dat$state, dat$idx)
grangertest(dat$idx, dat$state, order = 3)
grangertest(dat$idx, dat$state, order = 2)
grangertest(dat$idx, dat$state, order = 1)
grangertest(dat$idx, dat$state, order = 4)
grangertest(dat$idx, dat$state, order = 1)
grangertest(dat$state, dat$idx, order = 2)
grangertest(dat$state, dat$idx, order = 1)
grangertest(dat$state, dat$idx, order = 3)
grangertest(dat$idx, dat$state, order = 1)
grangertest(dat$state, dat$idx, order = 3)
grangertest(dat$idx, dat$state, order = 2)
grangertest(dat$idx, dat$state, order = 3)
grangertest(dat$idx, dat$state, order = 4)
grangertest(dat$idx, dat$state, order = 1)
